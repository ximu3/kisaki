/**
 * Pack Command
 *
 * Creates zip package for plugin distribution.
 * By default runs build first, use --no-build to skip.
 */

import { existsSync, readFileSync, writeFileSync, createWriteStream } from 'fs'
import { resolve, join } from 'path'
import { spawn } from 'child_process'
import archiver from 'archiver'
import semver from 'semver'
import { green, red, yellow, cyan, dim } from 'kolorist'

interface PackOptions {
  outdir: string
  build: boolean
}

interface PluginManifest {
  id?: string
  version?: string
  kisakiCompat?: string
  [key: string]: unknown
}

interface SdkPackageJson {
  kisakiCompat?: string
  [key: string]: unknown
}

/**
 * Run vite build and wait for completion
 */
async function runBuild(cwd: string): Promise<void> {
  return new Promise((resolve, reject) => {
    console.log(dim('  Running build...'))
    console.log()

    const vite = spawn('npx', ['vite', 'build'], {
      cwd,
      stdio: 'inherit',
      shell: true
    })

    vite.on('close', (code) => {
      if (code === 0) {
        console.log()
        resolve()
      } else {
        reject(new Error(`Build failed with exit code ${code}`))
      }
    })

    vite.on('error', reject)
  })
}

export async function packCommand(options: PackOptions): Promise<void> {
  const cwd = process.cwd()

  console.log()
  console.log(cyan('  kisaki-plugin pack'))
  console.log(dim('  Creating plugin package...'))
  console.log()

  // Run build first unless --no-build is specified
  if (options.build) {
    try {
      await runBuild(cwd)
    } catch (error) {
      console.log(red('✖') + ` Build failed: ${(error as Error).message}`)
      process.exit(1)
    }
  }

  // Check dist directory exists
  const distDir = resolve(cwd, options.outdir)
  if (!existsSync(distDir)) {
    console.log(red('✖') + ` Output directory not found: ${options.outdir}`)
    console.log(dim('  Run "kisaki-plugin build" first'))
    process.exit(1)
  }

  // Check manifest.json exists in dist (generated by build)
  const manifestPath = resolve(distDir, 'manifest.json')
  if (!existsSync(manifestPath)) {
    console.log(red('✖') + ' dist/manifest.json not found')
    console.log(dim('  Run "kisaki-plugin build" first'))
    process.exit(1)
  }

  try {
    // Read and process manifest
    const manifest: PluginManifest = JSON.parse(readFileSync(manifestPath, 'utf-8'))

    // Auto-fill kisakiCompat from SDK if not present
    if (!manifest.kisakiCompat) {
      const sdkCompat = getSdkKisakiCompat(cwd)
      if (sdkCompat) {
        manifest.kisakiCompat = sdkCompat
        console.log(cyan('ℹ') + ` kisakiCompat: ${sdkCompat} ${dim('(from SDK)')}`)
      } else {
        console.log(yellow('⚠') + ' kisakiCompat not set and SDK not found')
      }
    } else {
      // Validate manually set kisakiCompat
      if (!semver.validRange(manifest.kisakiCompat)) {
        console.log(red('✖') + ` Invalid kisakiCompat range: ${manifest.kisakiCompat}`)
        process.exit(1)
      }

      // Warn if lower than SDK requirement
      const sdkCompat = getSdkKisakiCompat(cwd)
      if (sdkCompat) {
        const sdkMin = semver.minVersion(sdkCompat)
        const manifestMin = semver.minVersion(manifest.kisakiCompat)
        if (sdkMin && manifestMin && semver.lt(manifestMin, sdkMin)) {
          console.log(
            yellow('⚠') +
              ` kisakiCompat (${manifest.kisakiCompat}) is lower than SDK requirement (${sdkCompat})`
          )
        }
      }
    }

    const zipPath = await createZipPackage(cwd, options.outdir, manifest)
    console.log(green('✓') + ` Created ${zipPath}`)
    console.log()
  } catch (error) {
    console.log(red('✖') + ` Failed: ${(error as Error).message}`)
    process.exit(1)
  }
}

/**
 * Get kisakiCompat from installed SDK
 */
function getSdkKisakiCompat(cwd: string): string | null {
  const sdkPkgPath = join(cwd, 'node_modules/@kisaki/plugin-sdk/package.json')

  if (!existsSync(sdkPkgPath)) {
    return null
  }

  try {
    const sdkPkg: SdkPackageJson = JSON.parse(readFileSync(sdkPkgPath, 'utf-8'))
    const compat = sdkPkg.kisakiCompat

    if (!compat) {
      return null
    }

    if (!semver.validRange(compat)) {
      console.log(yellow('⚠') + ` SDK has invalid kisakiCompat: ${compat}`)
      return null
    }

    return compat
  } catch {
    return null
  }
}

/**
 * Create zip package containing dist/ and manifest.json
 */
async function createZipPackage(
  cwd: string,
  outdir: string,
  manifest: PluginManifest
): Promise<string> {
  const pluginId = manifest.id || 'plugin'
  const version = manifest.version || '0.0.0'

  const zipFilename = `${pluginId}-${version}.zip`
  const zipPath = resolve(cwd, zipFilename)

  // Update manifest in dist/ with kisakiCompat if it was auto-filled
  const distManifestPath = resolve(cwd, outdir, 'manifest.json')
  writeFileSync(distManifestPath, JSON.stringify(manifest, null, 2))

  return new Promise((resolve, reject) => {
    const output = createWriteStream(zipPath)
    const archive = archiver('zip', { zlib: { level: 9 } })

    output.on('close', () => resolve(zipFilename))
    archive.on('error', (err: Error) => reject(err))

    archive.pipe(output)

    // Add dist directory contents directly to zip root (not nested under dist/)
    // This ensures manifest.json paths like "main/index.mjs" resolve correctly
    const distDir = resolvePath(cwd, outdir)
    if (existsSync(distDir)) {
      archive.directory(distDir, false)
    }

    // Add README if exists
    const readmePath = resolvePath(cwd, 'README.md')
    if (existsSync(readmePath)) {
      archive.file(readmePath, { name: 'README.md' })
    }

    archive.finalize()
  })
}

function resolvePath(cwd: string, path: string): string {
  return resolve(cwd, path)
}
